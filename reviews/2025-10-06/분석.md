#### glm-4.6의 분석
코드 분석을 완료했습니다. 모바일에서 GMH 패널이 스와이프/터치 시 자동으로 닫히는 버그의 원인이 될 만한 의심스러운 코드 영역들을 발견했습니다.

## 분석 결과 요약

### 1. 최근 버그 수정 내용 (CHANGELOG.md 확인)

- __v1.7.3 (2025-10-05)__: 모바일 패널 토글 중복 감지 수정

  - Galaxy S24 등에서 FAB 버튼 터치 시 패널이 반복적으로 켜졌다 꺼지는 문제
  - 350ms 타임스탬프 가드로 중복 토글 차단
  - `performance.now()` 기반 정밀 타이밍 체크

### 2. 의심스러운 코드 영역 분석

#### 🔥 __가장 의심스러운 영역: `panel-visibility.js`의 외부 포인터 핸들러__

```javascript
// src/ui/panel-visibility.js (약 320-340행 근처)
outsidePointerHandler = (event) => {
  if (!isModernActive()) return;
  if (isCollapsed()) return;
  const target = event.target;
  if (panelEl && panelEl.contains(target)) return;
  if (fabEl && fabEl.contains(target)) return;
  if (modal?.isOpen?.()) return;
  clearFocusMemory();
  close('user');  // ⚠️ 여기서 패널이 닫힘
};
doc.addEventListener('pointerdown', outsidePointerHandler);
```

__문제점:__

- `pointerdown` 이벤트가 패널 외부에서 발생하면 즉시 패널을 닫음
- 모바일에서는 스크롤/스와이프 시 `pointerdown`이 먼저 발생
- 패널 내부 요소가 아닌 경우 무조건 닫아버림

#### 🔥 __두 번째 의심 영역: 패널 내부 터치 이벤트 핸들러__

```javascript
// src/ui/panel-visibility.js (약 280-290행 근처)
const attachPanelListeners = () => {
  const passiveReset = () => resetIdleTimer();
  panelEl.addEventListener('touchstart', passiveReset, { passive: true });
  // ...
};
```

__문제점:__

- `touchstart` 이벤트는 패널 내부에서만 처리
- 하지만 패널 경계(border)나 스크롤 영역에서 터치가 외부로 간주될 수 있음

#### 🔥 __세 번째 의심 영역: FAB 버튼의 350ms 가드__

```javascript
// src/ui/panel-visibility.js (약 200-210행 근처)
fabEl.onclick = (event) => {
  const now = typeof performance?.now === 'function' ? performance.now() : Date.now();
  if (now - fabLastToggleAt < 350) return;  // ⚠️ 350ms 가드
  event.preventDefault();
  fabLastToggleAt = now;
  toggle();
};
```

__문제점:__

- 350ms 가드가 너무 짧을 수 있음
- 모바일에서는 터치 이벤트와 클릭 이벤트 사이의 지연이 더 길 수 있음

### 3. 모바일 특수 고려사항

1. __터치 이벤트 순서__: `touchstart → touchmove → touchend → mousedown → mouseup → click`
2. __포인터 이벤트__: `pointerdown → pointermove → pointerup` 순서
3. __모바일 브라우저별 차이__: iOS Safari vs Android Chrome의 이벤트 처리 차이

### 4. 재현 조건 추정

- 사용자가 패널을 열고 스크롤하려고 할 때
- 패널 경계나 스크롤바 영역을 터치하는 순간
- `pointerdown`이 패널 외부로 감지되어 즉시 닫힘
- 특히 작은 모바일 화면에서 더 자주 발생할 가능성

## 해결 방향 제안

1. __외부 포인터 핸들러 로직 개선__: 터치 이동 거리/시간을 고려한 지연 닫기
2. __터치 이벤트 경계 확장__: 패널 주변 버퍼 영역 포함
3. __모바일 특수 처리__: `touchstart` vs `pointerdown` 이벤트 구분

#### codex의 분석
  - src/ui/panel-visibility.js:342-358에서 collapseOnOutside 동작을 위해 전역 pointerdown 리스너가 등록되어
    있고, 패널·FAB·모달 이외의 영역을 터치하면 곧바로 close('user')가 호출됩니다. 모바일의 스와이프 제스처도
    pointerdown을 먼저 발생시키므로, 단순히 화면을 밀어 이동하려는 행동이 모두 “바깥 클릭”으로 오인되어 패
    널이 즉시 닫히는 구조입니다. 데스크톱에서 재현이 어려운 이유는 마우스 휠/트랙패드 스크롤이 pointerdown을
    만들지 않기 때문입니다.
  - src/ui/panel-settings.js:21-28에서 기본값으로 collapseOnOutside: true가 강제되며, 터치·펜·마우스에 대한
    구분이나 이동 거리 임계값 검사가 없어서 모든 디바이스에서 동일한 즉시-닫기 정책이 적용됩니다. 사용자 설
    정으로 끌 수는 있지만, 기본 UX가 모바일 제스처와 충돌합니다.
  - src/ui/panel-visibility.js:687-701의 close('user') 경로는 “사용자 의도”로 간주되기 때문에
    persistCollapsed(true)를 호출해 접힌 상태를 저장합니다. 외부 터치에 의해 의도치 않게 닫힌 뒤에는 FAB를
    다시 눌러야만 열리고, 심지어 세션 간에도 접힌 채로 남아 재사용성이 더 떨어집니다.
  - 최근 수정이었던 FAB 중복 토글 가드(src/ui/panel-visibility.js:423-431)는 터치 이벤트 폭주만 완화했을 뿐,
    위 pointerdown 기반 닫힘 로직과는 독립적이라 현재 보고된 현상에는 영향이 없습니다. 따라서 changelog의
    “해결” 항목과 달리 모바일 스와이프 문제는 여전히 남아 있는 것으로 보입니다.

  향후 검토하면 좋을 방향

  1. pointerType === 'mouse' 등으로 필터하거나, pointerup 시 실제 클릭 여부(이동 거리/시간)를 판단하는 식으
     로 모바일 스와이프를 구분해 collapseOnOutside를 보완할지 결정하기.
  2. 재현 영상을 참고해 터치 이동량을 로깅하거나 임시로 collapseOnOutside를 끈 상태로 비교 테스트해 의도치
     않은 닫힘이 사라지는지 확인하기.


#### claude의 분석
  핵심 문제 원인

  1. Outside Click Handler와 터치 이벤트 충돌 (src/ui/panel-visibility.js:342-359)

  outsidePointerHandler = (event) => {
    // ...
    const target = event.target;
    if (panelEl && panelEl.contains(target)) return;  // 패널 내부면 무시
    if (fabEl && fabEl.contains(target)) return;
    // ...
    close('user');  // 외부 클릭 시 패널 닫기
  };
  doc.addEventListener('pointerdown', outsidePointerHandler);

  문제점:
  - 모바일에서 패널 내부를 터치해서 스크롤하려고 할 때도 pointerdown 이벤트가 발생함
  - 이 이벤트가 document 레벨에서 감지되면서 outside click으로 오인될 수 있음

  2. 패널 이벤트 리스너의 passive 모드 (src/ui/panel-visibility.js:435-444)

  const attachPanelListeners = () => {
    // ...
    panelEl.addEventListener('pointerdown', passiveReset, { passive: true });
    panelEl.addEventListener('touchstart', passiveReset, { passive: true });
    // ...
  };

  문제점:
  - 패널 내부 이벤트가 passive: true로 설정됨
  - 이벤트 전파를 막을 수 없어서 document 레벨의 outsidePointerHandler도 함께 실행됨
  - 만약 event.target이 패널 외부로 잘못 감지되면 패널이 닫힘

  3. 가능한 시나리오들

  시나리오 A: 이벤트 타겟 오감지
  - 모바일 스크롤 시작 시 event.target이:
    - 스크롤바일 경우
    - CSS 가상 요소(::before, ::after)일 경우
    - 패널 경계의 미묘한 좌표일 경우
  - panelEl.contains(target)이 false를 반환 → 패널 닫힘

  시나리오 B: 터치 좌표 드리프트
  - 터치 시작할 때는 패널 내부였지만
  - 스크롤 제스처 중 손가락이 미묘하게 움직임
  - pointerdown의 좌표가 패널 밖으로 인식됨

  시나리오 C: 이벤트 버블링 순서
  - touchstart → pointerdown 순서로 이벤트 발생
  - 패널 내부 리스너(passive)가 이벤트를 먼저 소비하지 못함
  - Document 리스너가 먼저 또는 동시에 실행되어 잘못된 판단

  4. CSS 스크롤 구조 (src/ui/styles.js:63)

  .gmh-panel {
    overflow: auto;  /* 패널 전체에 스크롤 */
    max-height: 70vh;
  }

  패널 자체에 overflow: auto가 설정되어 있어서, 스크롤 시 패널 요소 자체가 스크롤 컨테이너가 됨. 이
  구조에서 터치 이벤트가 복잡하게 상호작용할 수 있음.

  의심가는 부분 요약

  1. 가장 유력: outsidePointerHandler에서 event.target이 모바일 스크롤 시작 시 패널 내부임에도 외부로
  감지되는 케이스
  2. 두번째: 패널 내부 passive: true 리스너가 document 레벨 핸들러보다 우선순위가 낮아서 이벤트 전파를
  막지 못함
  3. 세번째: 특정 모바일 브라우저에서 panelEl.contains(target) 체크가 제대로 작동하지 않음 (스크롤바,
  가상 요소 등)

  제안 해결 방향 (코드 수정은 하지 않았음)

  1. outsidePointerHandler에 모바일 감지 추가해서 터치 스크롤 시작을 구분
  2. event.target 체크를 더 robust하게 (composedPath 사용 등)
  3. Outside click을 pointerdown 대신 click 이벤트로 변경 (스크롤은 click 발생 안 함)
  4. 타임스탬프 기반으로 빠른 연속 이벤트 무시 (v1.7.3 FAB 가드와 유사)