// ==UserScript==
// @name         Genit Memory Helper
// @namespace    local.dev
// @version      0.7
// @description  Genit ÎåÄÌôîÎ°úÍ∑∏ JSON/TXT/MD Ï∂îÏ∂ú + ÏöîÏïΩ/Ïû¨ÏöîÏïΩ ÌîÑÎ°¨ÌîÑÌä∏ Î≥µÏÇ¨ Í∏∞Îä•
// @author       devforai-creator
// @match        https://genit.ai/*
// @match        https://www.genit.ai/*
// @grant        GM_setClipboard
// @run-at       document-idle
// @updateURL    https://github.com/devforai-creator/genit-memory-helper/raw/main/genit-memory-helper.user.js
// @downloadURL  https://github.com/devforai-creator/genit-memory-helper/raw/main/genit-memory-helper.user.js
// @license      MIT
// ==/UserScript==

(function () {
  'use strict';

  // -------------------------------
  // 0) Constants & utils
  // -------------------------------
  const PLAYER_MARK = '‚ü¶PLAYER‚üß ';
  const HEADER_RE =
    /^(\d+Ïõî\s*\d+Ïùº.*?\d{1,2}:\d{2})\s*\|\s*([^|]+?)\s*\|\s*üìç\s*([^|]+)\s*\|?(.*)$/;
  const CODE_RE = /^([A-J])\/(\d+)\/(\d+)\/(\d+)\/(\d+)$/i;
  const META_KEYWORDS = ['ÏßÄÎèÑ', 'Îì±Ïû•', 'Actors', 'Î∞∞Ïö∞', 'Í∏∞Î°ùÏΩîÎìú', 'Codes', 'SCENE'];
  const PLAYER_NAME_FALLBACKS = ['ÌîåÎ†àÏù¥Ïñ¥', 'ÏÜåÏ§ëÌïúÏΩîÏïåÎùº5299'];

  function normNL(s) {
    return String(s ?? '').replace(/\r\n?|\u2028|\u2029/g, '\n');
  }

  function stripTicks(s) {
    return String(s ?? '').replace(/```+/g, '');
  }

  function collapseSpaces(s) {
    return String(s ?? '')
      .replace(/\s+/g, ' ')
      .replace(/\s{2,}/g, ' ')
      .trim();
  }

  function stripQuotes(s) {
    return String(s ?? '')
      .replace(/^['"‚Äú‚Äù„Äé„Äå„Ää„Äê]+/, '')
      .replace(/['"‚Äú‚Äù„Äè„Äç„Äã„Äë]+$/, '')
      .trim();
  }

  function stripBrackets(v) {
    return String(v ?? '').replace(/^\[|\]$/g, '').trim();
  }

  function sanitizeText(s) {
    return collapseSpaces(normNL(s).replace(/[\t\v\f\u00a0\u200b]/g, ' '));
  }

  function looksLikeName(raw) {
    const s = String(raw ?? '')
      .replace(/^[\-‚Ä¢\s]+/, '')
      .trim();
    if (!s) return false;
    if (/^(INFO|Î©îÏãúÏßÄ Ïù¥ÎØ∏ÏßÄ)$/i.test(s)) return false;
    return /^[Í∞Ä-Ìû£A-Za-z][\wÍ∞Ä-Ìû£ .,'‚Äô]{0,24}$/.test(s);
  }

  function looksNarrative(line) {
    const s = line.trim();
    if (!s) return false;
    if (/^[\[\(].*[\]\)]$/.test(s)) return true;
    if (/^(...|¬∑¬∑¬∑|‚Ä¶)/.test(s)) return true;
    if (/^(ÎãπÏã†|ÎÑàÎäî|Í∑∏Îäî|Í∑∏ÎÖÄÎäî)\s/.test(s)) return true;
    return false;
  }

  function isActorStatsLine(line) {
    return /\|/.test(line) && /‚ù§Ô∏è|üíó|üí¶|ü™£/.test(line);
  }

  function isMetaLine(line) {
    const stripped = stripBrackets(line);
    if (!stripped) return true;
    if (/^INFO$/i.test(stripped)) return true;
    if (isActorStatsLine(stripped)) return true;
    if (/^Î©îÏãúÏßÄ Ïù¥ÎØ∏ÏßÄ$/i.test(stripped)) return true;
    if (CODE_RE.test(stripped.replace(/\s+/g, ''))) return true;
    for (const keyword of META_KEYWORDS) {
      if (stripped.startsWith(keyword)) return true;
    }
    if (/^[-=]{3,}$/.test(stripped)) return true;
    return false;
  }

  function guessPlayerNamesFromDOM() {
    const cands = new Set();
    const selectors = [
      '[data-username]',
      '[data-profile-name]',
      '.profile-name',
      '.user-name',
      'header [class*="name"]',
      'nav [class*="name"]',
    ];
    for (const sel of selectors) {
      document.querySelectorAll(sel).forEach((node) => {
        const text = node.textContent?.trim();
        if (text && /^[\wÍ∞Ä-Ìû£][\wÍ∞Ä-Ìû£ _.-]{1,20}$/.test(text)) cands.add(text);
      });
    }
    return Array.from(cands);
  }

  const PLAYER_NAMES = Array.from(
    new Set([...PLAYER_NAME_FALLBACKS, ...guessPlayerNamesFromDOM()].filter(Boolean))
  );

  const PLAYER_ALIASES = new Set(
    PLAYER_NAMES.map((n) => n.toLowerCase()).concat(['player', 'ÌîåÎ†àÏù¥Ïñ¥', 'Ïú†Ï†Ä', 'ÎÇò'])
  );

  function normalizeSpeakerName(name) {
    const stripped = collapseSpaces(name)
      .replace(/[\[\]{}()]+/g, '')
      .replace(/^[-‚Ä¢]+/, '')
      .trim();
    if (!stripped) return 'ÎÇ¥Î†àÏù¥ÏÖò';
    const lower = stripped.toLowerCase();
    if (PLAYER_ALIASES.has(lower)) return PLAYER_NAMES[0] || 'ÌîåÎ†àÏù¥Ïñ¥';
    if (/^(system|ÏãúÏä§ÌÖú|ÎÇ¥Î†àÏù¥ÏÖò|narration)$/i.test(lower)) return 'ÎÇ¥Î†àÏù¥ÏÖò';
    return stripped;
  }

  function roleForSpeaker(name) {
    if (name === 'ÎÇ¥Î†àÏù¥ÏÖò') return 'narration';
    if (PLAYER_NAMES.includes(name)) return 'player';
    return 'npc';
  }

  function normalizeTranscript(raw) {
    return stripTicks(normNL(raw)).replace(/[\t\u00a0\u200b]/g, ' ');
  }

  // -------------------------------
  // 1) Turns-first parser
  // -------------------------------
  function parseTurns(raw) {
    const lines = normalizeTranscript(raw).split('\n');
    const turns = [];
    const warnings = [];
    const metaHints = { header: null, codes: [], titles: [] };

    let currentSceneId = 1;
    let pendingSpeaker = null;

    const pushTurn = (speaker, text, roleOverride) => {
      const textClean = sanitizeText(text);
      if (!textClean) return;
      const speakerName = normalizeSpeakerName(speaker || 'ÎÇ¥Î†àÏù¥ÏÖò');
      const role = roleOverride || roleForSpeaker(speakerName);
      const last = turns[turns.length - 1];
      if (last && last.speaker === speakerName && last.role === role) {
        last.text = `${last.text} ${textClean}`.trim();
        return;
      }
      turns.push({
        speaker: speakerName,
        role,
        text: textClean,
        sceneId: currentSceneId,
      });
    };

    for (let i = 0; i < lines.length; i++) {
      let original = lines[i] ?? '';
      if (!original) continue;
      let line = original.trim();
      if (!line) continue;

      const headerMatch = HEADER_RE.exec(line);
      if (headerMatch) {
        if (!metaHints.header) metaHints.header = headerMatch;
        currentSceneId += 1;
        pendingSpeaker = null;
        continue;
      }

      if (/^#/.test(line) && line.length <= 80) {
        metaHints.titles.push(stripQuotes(line.replace(/^#+/, '').trim()));
        pendingSpeaker = null;
        continue;
      }

      if (CODE_RE.test(line.replace(/\s+/g, ''))) {
        metaHints.codes.push(line.trim());
        pendingSpeaker = null;
        continue;
      }

      if (stripBrackets(line).toUpperCase() === 'INFO') {
        currentSceneId += 1;
        pendingSpeaker = null;
        continue;
      }

      let forcedPlayer = false;
      if (line.startsWith(PLAYER_MARK)) {
        forcedPlayer = true;
        line = line.slice(PLAYER_MARK.length).trim();
      }
      if (!line) continue;

      if (isMetaLine(line)) {
        pendingSpeaker = null;
        continue;
      }

      let m = line.match(/^@([^@]{1,40})@\s*["‚Äú]?([\s\S]+?)["‚Äù]?\s*$/);
      if (m) {
        const speaker = normalizeSpeakerName(m[1]);
        pushTurn(speaker, m[2], roleForSpeaker(speaker));
        pendingSpeaker = speaker;
        continue;
      }

      if (forcedPlayer) {
        const speaker = PLAYER_NAMES[0] || 'ÌîåÎ†àÏù¥Ïñ¥';
        pushTurn(speaker, stripQuotes(line), 'player');
        pendingSpeaker = speaker;
        continue;
      }

      m = line.match(/^([^:@‚Äî\-]{1,40})\s*[:\-‚Äî]\s*(.+)$/);
      if (m && looksLikeName(m[1])) {
        const speaker = normalizeSpeakerName(m[1]);
        pushTurn(speaker, stripQuotes(m[2]), roleForSpeaker(speaker));
        pendingSpeaker = speaker;
        continue;
      }

      if (looksLikeName(line)) {
        const speaker = normalizeSpeakerName(line);
        let textBuf = [];
        let j = i + 1;
        while (j < lines.length) {
          let peek = (lines[j] || '').trim();
          if (!peek) {
            j += 1;
            break;
          }
          let peekForced = false;
          if (peek.startsWith(PLAYER_MARK)) {
            peekForced = true;
            peek = peek.slice(PLAYER_MARK.length).trim();
          }
          if (!peek) {
            j += 1;
            continue;
          }
          if (HEADER_RE.test(peek) || stripBrackets(peek).toUpperCase() === 'INFO') break;
          if (isMetaLine(peek)) break;
          if (peekForced) break;
          if (looksLikeName(peek) || /^@[^@]+@/.test(peek)) break;
          textBuf.push(peek);
          j += 1;
          if (!/["‚Äù]$/.test(peek)) break;
        }
        if (textBuf.length) {
          pushTurn(speaker, stripQuotes(textBuf.join(' ')), roleForSpeaker(speaker));
          pendingSpeaker = speaker;
          i = j - 1;
          continue;
        }
        pendingSpeaker = speaker;
        continue;
      }

      if (looksNarrative(line) || /^".+"$/.test(line) || /^‚Äú.+‚Äù$/.test(line)) {
        pushTurn('ÎÇ¥Î†àÏù¥ÏÖò', stripQuotes(line), 'narration');
        pendingSpeaker = null;
        continue;
      }

      if (pendingSpeaker) {
        pushTurn(pendingSpeaker, stripQuotes(line), roleForSpeaker(pendingSpeaker));
        continue;
      }

      if (line.length <= 30 && /[!?‚Ä¶]$/.test(line) && turns.length) {
        const last = turns[turns.length - 1];
        last.text = `${last.text} ${line}`.trim();
        continue;
      }

      pushTurn('ÎÇ¥Î†àÏù¥ÏÖò', line, 'narration');
      pendingSpeaker = null;
    }

    return { turns, warnings, metaHints };
  }

  function deriveMeta(metaHints, turns) {
    const meta = {};
    if (metaHints.header) {
      const [, time, modeRaw, placeRaw] = metaHints.header;
      if (time) meta.date = time.trim();
      if (modeRaw) meta.mode = modeRaw.trim();
      if (placeRaw) meta.place = placeRaw.trim();
    }
    const title = metaHints.titles.find(Boolean);
    if (title) meta.title = title;

    const actorSet = new Set();
    for (const t of turns) {
      if (t.role === 'player' || t.role === 'npc') actorSet.add(t.speaker);
    }
    meta.actors = Array.from(actorSet);
    if (!meta.title && meta.place) meta.title = `${meta.place} ÏÑ∏ÏÖò`;
    meta.player = PLAYER_NAMES[0] || 'ÌîåÎ†àÏù¥Ïñ¥';
    meta.turn_count = turns.length;
    meta.scene_count = new Set(turns.map((t) => t.sceneId)).size;
    return meta;
  }

  function buildSession(raw) {
    const { turns, warnings, metaHints } = parseTurns(raw);
    const meta = deriveMeta(metaHints, turns);
    return {
      meta,
      turns,
      warnings,
      source: 'genit-memory-helper',
    };
  }

  // -------------------------------
  // 2) Writers (JSON / TXT / Markdown)
  // -------------------------------
  function toJSONExport(session, normalizedRaw) {
    const payload = {
      version: '1.0',
      generated_at: new Date().toISOString(),
      source: session.source,
      player_names: PLAYER_NAMES,
      meta: session.meta,
      turns: session.turns,
      warnings: session.warnings,
      raw_excerpt: (normalizedRaw || '').slice(0, 2000),
    };
    return JSON.stringify(payload, null, 2);
  }

  function toTXTExport(session, opts = {}) {
    const turns = opts.turns || session.turns;
    const includeMeta = opts.includeMeta !== false;
    const lines = [];
    if (includeMeta) {
      if (session.meta.title) lines.push(`# TITLE: ${session.meta.title}`);
      if (session.meta.date) lines.push(`# DATE: ${session.meta.date}`);
      if (session.meta.place) lines.push(`# PLACE: ${session.meta.place}`);
      if (session.meta.actors?.length) lines.push(`# ACTORS: ${session.meta.actors.join(', ')}`);
      lines.push('');
    }
    for (const t of turns) {
      const speaker = t.role === 'narration' ? 'ÎÇ¥Î†àÏù¥ÏÖò' : t.speaker;
      lines.push(`@${speaker}@ ${t.text}`);
    }
    return lines.join('\n').trim();
  }

  function toMarkdownExport(session, opts = {}) {
    const turns = opts.turns || session.turns;
    const heading = opts.heading || '# ÎåÄÌôî Î°úÍ∑∏';
    const includeMeta = opts.includeMeta !== false;
    const lines = [heading];
    if (includeMeta) {
      const metaLines = [];
      if (session.meta.date) metaLines.push(`- ÎÇ†Ïßú: ${session.meta.date}`);
      if (session.meta.place) metaLines.push(`- Ïû•ÏÜå: ${session.meta.place}`);
      if (session.meta.mode) metaLines.push(`- Î™®Îìú: ${session.meta.mode}`);
      if (session.meta.actors?.length)
        metaLines.push(`- Ï∞∏Ïó¨Ïûê: ${session.meta.actors.join(', ')}`);
      if (metaLines.length) {
        lines.push(metaLines.join('\n'));
        lines.push('');
      }
    } else {
      lines.push('');
    }
    for (const t of turns) {
      if (t.role === 'narration') {
        lines.push(`> **ÎÇ¥Î†àÏù¥ÏÖò**: ${t.text}`);
      } else {
        lines.push(`- **${t.speaker}**: ${t.text}`);
      }
    }
    return lines.join('\n').trim();
  }

  function buildExportBundle(session, normalizedRaw, format) {
    const stamp = new Date().toISOString().replace(/[:.]/g, '-');
    const base = `genit_turns_${stamp}`;
    if (format === 'md') {
      return {
        filename: `${base}.md`,
        mime: 'text/markdown',
        content: toMarkdownExport(session),
      };
    }
    if (format === 'txt') {
      return {
        filename: `${base}.txt`,
        mime: 'text/plain',
        content: toTXTExport(session),
      };
    }
    return {
      filename: `${base}.json`,
      mime: 'application/json',
      content: toJSONExport(session, normalizedRaw),
    };
  }

  // -------------------------------
  // 3) DOM Reader
  // -------------------------------
  const CHAT_CONTAINER_SEL = '.flex-1.min-h-0.overflow-y-auto';
  const MSG_ROOT_SEL = '[data-message-id]';

  function readTranscriptText() {
    const root = document.querySelector(CHAT_CONTAINER_SEL);
    if (!root) throw new Error('Ï±ÑÌåÖ Ïª®ÌÖåÏù¥ÎÑàÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');

    const blocks = Array.from(root.querySelectorAll(MSG_ROOT_SEL));
    const seenLine = new Set();
    const out = [];

    const pushLine = (line) => {
      const s = (line || '').trim();
      if (!s) return;
      if (seenLine.has(s)) return;
      seenLine.add(s);
      out.push(s);
    };

    for (const b of blocks) {
      const infoCode = b.querySelector('code.language-INFO');
      if (infoCode) {
        pushLine('INFO');
        infoCode.textContent
          .split(/\r?\n/)
          .map((s) => s.trimEnd())
          .forEach((s) => pushLine(s));
      }

      const userScopes = b.querySelectorAll(
        '.flex.w-full.justify-end, .flex.flex-col.items-end'
      );
      for (const scope of userScopes) {
        scope.querySelectorAll('.p-4.rounded-xl.bg-background p').forEach((p) => {
          const txt = p.innerText?.trim();
          if (!txt) return;
          pushLine(PLAYER_MARK + txt);
        });
        scope.querySelectorAll('.markdown-content.text-right').forEach((md) => {
          const t = md.innerText?.trim();
          if (!t) return;
          t.split(/\n+/).forEach((row) => pushLine(PLAYER_MARK + row.trim()));
        });
      }

      b.querySelectorAll('.flex.flex-col.w-full.group').forEach((group) => {
        const name = group.querySelector(
          '.text-sm.text-muted-foreground.mb-1.ml-1'
        )?.innerText?.trim();
        const bubblePs = group.querySelectorAll('.p-4.rounded-xl.bg-background p');
        if (!name || !bubblePs.length) return;
        if (group.closest('.justify-end, .items-end')) return;

        bubblePs.forEach((p) => {
          const txt = p.innerText?.trim();
          if (!txt) return;
          pushLine(`@${name}@ "${txt}"`);
        });
      });

      b.querySelectorAll('.markdown-content.text-muted-foreground.text-sm').forEach(
        (md) => {
          if (md.closest('.justify-end, .items-end, .text-right')) return;
          const t = md.innerText?.trim();
          if (!t) return;
          t.split(/\n+/).forEach((row) => pushLine(row.trim()));
        }
      );
    }

    return out.join('\n');
  }

  // -------------------------------
  // 4) UI Panel
  // -------------------------------
  function mountPanel() {
    if (document.querySelector('#genit-memory-helper-panel')) return;
    const panel = document.createElement('div');
    panel.id = 'genit-memory-helper-panel';
    panel.style.cssText = `
      position: fixed; right: 16px; bottom: 16px; z-index: 999999;
      background: #0b1020; color: #fff; padding: 10px 12px; border-radius: 10px;
      font: 12px/1.3 ui-sans-serif, system-ui; box-shadow: 0 8px 20px rgba(0,0,0,.4);
      display: grid; gap: 8px; min-width: 260px;
    `;
    panel.innerHTML = `
      <div style="font-weight:600">Genit Memory Helper</div>
      <div style="display:flex; gap:8px;">
        <button id="gmh-copy-recent" style="flex:1; background:#22c55e; border:0; color:#051; border-radius:8px; padding:8px; cursor:pointer;">ÏµúÍ∑º 15ÌÑ¥ Î≥µÏÇ¨</button>
        <button id="gmh-copy-all" style="flex:1; background:#60a5fa; border:0; color:#031; border-radius:8px; padding:8px; cursor:pointer;">Ï†ÑÏ≤¥ MD Î≥µÏÇ¨</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <select id="gmh-export-format" style="flex:1; background:#111827; color:#f1f5f9; border:1px solid #1f2937; border-radius:8px; padding:8px;">
          <option value="json">JSON (.json)</option>
          <option value="txt">TXT (.txt)</option>
          <option value="md">Markdown (.md)</option>
        </select>
        <button id="gmh-export" style="flex:1; background:#2dd4bf; border:0; color:#052; border-radius:8px; padding:8px; cursor:pointer;">ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button>
      </div>
      <div style="display:flex; gap:8px;">
        <button id="gmh-reparse" style="flex:1; background:#f59e0b; border:0; color:#210; border-radius:8px; padding:8px; cursor:pointer;">Ïû¨ÌååÏã±</button>
        <button id="gmh-guide" style="flex:1; background:#a78bfa; border:0; color:#210; border-radius:8px; padding:8px; cursor:pointer;">ÏöîÏïΩ Í∞ÄÏù¥Îìú</button>
      </div>
      <div style="display:flex; gap:8px;">
        <button id="gmh-reguide" style="flex:1; background:#fbbf24; border:0; color:#210; border-radius:8px; padding:8px; cursor:pointer;">Ïû¨ÏöîÏïΩ Í∞ÄÏù¥Îìú</button>
      </div>
      <div id="gmh-status" style="opacity:.85"></div>
    `;
    document.body.appendChild(panel);

    const statusEl = panel.querySelector('#gmh-status');
    const setStatus = (msg, color = '#9ca3af') => {
      if (statusEl) {
        statusEl.textContent = msg;
        statusEl.style.color = color;
      }
    };

    const parseAll = () => {
      const raw = readTranscriptText();
      const normalized = normalizeTranscript(raw);
      const session = buildSession(normalized);
      if (!session.turns.length) throw new Error('ÎåÄÌôî ÌÑ¥ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      return { session, raw: normalized };
    };

    panel.querySelector('#gmh-copy-recent').onclick = () => {
      try {
        const { session } = parseAll();
        const turns = session.turns.slice(-15);
        const md = toMarkdownExport(session, {
          turns,
          includeMeta: false,
          heading: '## ÏµúÍ∑º 15ÌÑ¥',
        });
        GM_setClipboard(md, { type: 'text', mimetype: 'text/plain' });
        setStatus(`ÏµúÍ∑º 15ÌÑ¥ Î≥µÏÇ¨ ÏôÑÎ£å. Ï¥ù ÌÑ¥ ${session.turns.length}Í∞ú.`, '#a7f3d0');
        if (session.warnings.length) console.warn('[GMH] warnings:', session.warnings);
      } catch (e) {
        alert(`Ïò§Î•ò: ${(e && e.message) || e}`);
        setStatus('Î≥µÏÇ¨ Ïã§Ìå®', '#fecaca');
      }
    };

    panel.querySelector('#gmh-copy-all').onclick = () => {
      try {
        const { session } = parseAll();
        const md = toMarkdownExport(session);
        GM_setClipboard(md, { type: 'text', mimetype: 'text/plain' });
        setStatus(`Ï†ÑÏ≤¥ Markdown Î≥µÏÇ¨ ÏôÑÎ£å. ÌÑ¥ ${session.turns.length}Í∞ú.`, '#bfdbfe');
        if (session.warnings.length) console.warn('[GMH] warnings:', session.warnings);
      } catch (e) {
        alert(`Ïò§Î•ò: ${(e && e.message) || e}`);
        setStatus('Î≥µÏÇ¨ Ïã§Ìå®', '#fecaca');
      }
    };

    panel.querySelector('#gmh-export').onclick = () => {
      try {
        const { session, raw } = parseAll();
        const select = panel.querySelector('#gmh-export-format');
        const format = select?.value || 'json';
        const bundle = buildExportBundle(session, raw, format);
        const blob = new Blob([bundle.content], { type: bundle.mime });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = bundle.filename;
        a.click();
        URL.revokeObjectURL(a.href);
        setStatus(`${format.toUpperCase()} ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏôÑÎ£å. ÌÑ¥ ${session.turns.length}Í∞ú.`, '#d1fae5');
        if (session.warnings.length) console.warn('[GMH] warnings:', session.warnings);
      } catch (e) {
        alert(`Ïò§Î•ò: ${(e && e.message) || e}`);
        setStatus('ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®', '#fecaca');
      }
    };

    panel.querySelector('#gmh-reparse').onclick = () => {
      try {
        const { session } = parseAll();
        setStatus(`Ïû¨ÌååÏã± ÏôÑÎ£å: ÌÑ¥ ${session.turns.length}Í∞ú. Í≤ΩÍ≥† ${session.warnings.length}Í±¥.`, '#fde68a');
        if (session.warnings.length) console.warn('[GMH] warnings:', session.warnings);
      } catch (e) {
        alert(`Ïò§Î•ò: ${(e && e.message) || e}`);
        setStatus('Ïû¨ÌååÏã± Ïã§Ìå®', '#fecaca');
      }
    };

    panel.querySelector('#gmh-guide').onclick = () => {
      const prompt = `
ÎãπÏã†ÏùÄ "Ïû•Í∏∞Í∏∞Ïñµ Î≥¥Í¥ÄÏö© ÏÇ¨ÏÑú"ÏûÖÎãàÎã§.
ÏïÑÎûò ÌååÏùºÏùÄ Ï∫êÎ¶≠ÌÑ∞ Ï±ÑÌåÖ Î°úÍ∑∏Î•º Ï†ïÌòïÌôîÌïú Í≤ÉÏûÖÎãàÎã§.
Î™©ÌëúÎäî Ïù¥ Îç∞Ïù¥ÌÑ∞Î•º 2000Ïûê Ïù¥ÎÇ¥Î°ú ÏöîÏïΩÌïòÏó¨, Ï∫êÎ¶≠ÌÑ∞ ÌîåÎû´ÌèºÏùò "Ïú†Ï†ÄÎÖ∏Ìä∏"Ïóê ÎÑ£ÏùÑ Ïàò ÏûàÎäî ÌòïÏãùÏúºÎ°ú Ï†ïÎ¶¨ÌïòÎäî Í≤ÉÏûÖÎãàÎã§.

Ï°∞Í±¥:
1. Ï§ëÏöîÎèÑ Í∏∞Ï§Ä
   - ÌîåÎ†àÏù¥Ïñ¥ÏôÄ NPC Í¥ÄÍ≥Ñ Î≥ÄÌôî, ÏïΩÏÜç, Î™©Ìëú, Í∞àÎì±, ÏÑ†Ìò∏/Í∏àÍ∏∞Îßå Ìè¨Ìï®.
   - ÏÇ¨ÏÜåÌïú ÎÜçÎã¥¬∑Ïû°Îã¥ÏùÄ Ï†úÏô∏.
   - ÏµúÍ∑ºÏùºÏàòÎ°ù Îçî ÎπÑÏ§ë ÏûàÍ≤å Î∞òÏòÅ.

2. Ï∂úÎ†• Íµ¨Ï°∞
   - [Ï†ÑÏ≤¥ Ï§ÑÍ±∞Î¶¨ ÏöîÏïΩ]: Ï£ºÏöî ÏÇ¨Í±¥ ÌùêÎ¶ÑÏùÑ 3~6Í∞ú Ìï≠Î™©ÏúºÎ°ú.
   - [Ï£ºÏöî Í¥ÄÍ≥Ñ Î≥ÄÌôî]: NPCÎ≥Ñ Í∞êÏ†ï/ÌÉúÎèÑ Î≥ÄÌôîÎ•º Ï†ïÎ¶¨.
   - [ÌïµÏã¨ ÌÖåÎßà]: Î∞òÎ≥µÎêú Í∑úÏπô, ÏÑ∏Í≥ÑÍ¥Ä ÏöîÏÜå, Î™©Ìëú.

3. ÌòïÏãù Í∑úÏπô
   - Ï†ÑÏ≤¥ Í∏∏Ïù¥Îäî 1200~1800Ïûê.
   - Î¨∏Ïû•ÏùÄ Í∞ÑÍ≤∞ÌïòÍ≤å.
   - ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶ÑÏùÄ "ÌîåÎ†àÏù¥Ïñ¥"Î°ú ÌÜµÏùº.
`;
      GM_setClipboard(prompt, { type: 'text', mimetype: 'text/plain' });
      setStatus('‚úÖ ÏöîÏïΩ ÌîÑÎ°¨ÌîÑÌä∏Í∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§.', '#c4b5fd');
    };

    panel.querySelector('#gmh-reguide').onclick = () => {
      const prompt = `
ÏïÑÎûòÏóêÎäî [Ïù¥Ï†Ñ ÏöîÏïΩÎ≥∏]Í≥º [ÏÉà Î°úÍ∑∏ ÌååÏùº]Ïù¥ ÏûàÏäµÎãàÎã§.
Ïù¥ ÎëòÏùÑ ÌÜµÌï©ÌïòÏó¨, 2000Ïûê Ïù¥ÎÇ¥Ïùò "ÏµúÏã† Ïû•Í∏∞Í∏∞Ïñµ ÏöîÏïΩÎ≥∏"ÏùÑ ÎßåÎìúÏÑ∏Ïöî.

Í∑úÏπô:
- Ïù¥Ï†Ñ ÏöîÏïΩÎ≥∏ÏóêÏÑú Ïù¥ÎØ∏ ÏûàÎäî ÏÇ¨Ïã§ÏùÄ Ïú†ÏßÄÌïòÎêò, ÏÉà Î°úÍ∑∏ ÌååÏùºÏóê ÎÇòÏò® ÏÇ¨Í±¥/Í¥ÄÍ≥Ñ Î≥ÄÌôîÎ°ú ÏóÖÎç∞Ïù¥Ìä∏.
- Î™®ÏàúÎêòÎ©¥ "ÏµúÍ∑º ÏÇ¨Í±¥"ÏùÑ Ïö∞ÏÑ†.
- Ï∂úÎ†• Íµ¨Ï°∞Îäî [Ï†ÑÏ≤¥ Ï§ÑÍ±∞Î¶¨ ÏöîÏïΩ] / [Ï£ºÏöî Í¥ÄÍ≥Ñ Î≥ÄÌôî] / [ÌïµÏã¨ ÌÖåÎßà].
- Í∏∏Ïù¥Îäî 1200~1800Ïûê.
`;
      GM_setClipboard(prompt, { type: 'text', mimetype: 'text/plain' });
      setStatus('‚úÖ Ïû¨ÏöîÏïΩ ÌîÑÎ°¨ÌîÑÌä∏Í∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§.', '#fcd34d');
    };
  }

  // -------------------------------
  // 5) Boot
  // -------------------------------
  function boot() {
    try {
      mountPanel();
    } catch (e) {
      console.error('[GMH] mount error', e);
    }
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(boot, 1200);
  } else {
    window.addEventListener('DOMContentLoaded', () => setTimeout(boot, 1200));
  }

  const mo = new MutationObserver(() => {
    if (!document.querySelector('#genit-memory-helper-panel')) boot();
  });
  mo.observe(document.documentElement, { subtree: true, childList: true });
})();
